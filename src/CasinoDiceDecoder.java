import java.io.File;
import java.io.FileWriter;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.*;
/*
 * Author: Anuja Nagare
 * 		   Matthew Haneburger
 * Email: anuja.nagare@uga.edu
 *        reiner@uga.edu
 * 
 * */

public class CasinoDiceDecoder {
	
	public static String inputFile = "F:/MS Sem 1/Algo/Project/CasinoDiceInput.txt";
	public static File outputFile = new File("F:/MS Sem 1/Algo/Project/CasinoDiceOutput.txt");
	public static String inputFilehmm = "F:/MS Sem 1/Algo/Project/hmm.txt";
	static double Btf;
	static double Ftf;
	static double Ltl;
	static double ld6;
	static String inhmm = "";
	static Scanner in = new Scanner(System.in);
	static int n=in.nextInt();		
	static List<String> rolls1 = new ArrayList<String>();
	
	
	/**
	 * Reads a file which consists of HMM 
	 */
	public String fileread() throws FileNotFoundException

	{
		File file = new File(inputFilehmm);
		Scanner scan = new Scanner(file);
		String inputhmm = "";

		while(scan.hasNextLine())
		{
		inputhmm =inhmm.concat(scan.nextLine());
		inputhmm.split(" ");
		}
		scan.close();
		
		return inputhmm;
	}//fileread

	
	@SuppressWarnings({ "unused", "static-access" })
	public static void main(String[] args) throws FileNotFoundException, IOException {

		CasinoDiceDecoder obj = new CasinoDiceDecoder();
		double [] Num = new double [6] ;

		double inDouble=0;
		
		for(int j=0;j<4;j++)
		{				
		Num[j]=Double.parseDouble(obj.fileread().split(" ")[j]);
		}
		
		Btf=Num[0];
		Ftf=Num[1];
		Ltl=Num[2];
		ld6=Num[3];

		obj.fileread();

		File file = new File(inputFile);
		Scanner scan = new Scanner(file);
		String input;

		//input takes in a line of numbers
		input = scan.nextLine();
		String output = diceDecoder(input);

		scan.close();

		System.out.println(obj.temp);
	}
	
	/*calculates the probability of a number being rolled with a loaded die
	 * P(1)=P(2)=P(3) =P(4) =P(5) and P(6)=0.5
	 * */
	public static double loadedRoll(char die) {
		double LD=0.0;
			if (die == '6') {
				 LD = 0.5;
			}

			else if(die == '1' || die == '2' ||die == '3' ||die == '4' ||die == '5'){
				 LD = 0.1;
		}
			return LD;
	}

	//Decodes a particular sequence of dice rolls...Algorithm origin from LIMING CAIs lecture notes Fall 2015
	//Initially chose to use an ArrayList as the data structure
	
	/*Begin Previous Attempt
	 * 
	 * Scanner scanner = new Scanner(new File(inputFile));
	List<Integer> list = new ArrayList<Integer>();
	while (scanner.hasNextInt()) {
		list.add(scanner.nextInt());
	}
	*
	*End Previous Attempt
	*/
	
	public static String diceDecoder(String sequence) throws IOException {
		/*we initialize an array M to store the probabilities of the rolls and 
		 * Array P to store which die was used on each roll*/ 
		double[][] M = new double[2][sequence.length()];
		int[][] P = new int[2][sequence.length()];

		/*the top row will be the fair die 
		 * 1/2 is multiplied by the probability of obtaining any number on a fair die which is 1/6
		 * */
		M[0][0] = (Btf) * (1.0 / 6.0);
		/*the bottom row will be the loaded die
		 *1/2 is multiplied by the probability generated by the loadedRoll method
		 * */
		M[1][0] = (1-Btf) * loadedRoll(sequence.charAt(0));

		int j = 1;
		/*
		 * AS SEQUENCE GETS LARGER, THE PROBABILITY APPROACHES ZERO!!!
		 * 
		 * */
		while(j < sequence.length()) {
			/*this is the probability after we know the first state*/
			if (M[0][j - 1] * Ftf * (1.0 / 6.0) >= M[1][j - 1] * (1-Ftf) * (1.0 / 6.0)) {
				M[0][j] = M[0][j - 1] * Ftf * (1.0 / 6.0);
				//initialized to fair
				P[0][j] = 0;

			}

			else {
				M[0][j] = M[1][j - 1] * (1-Ltl) * (1.0 / 6.0);
				//initialized to loaded
				P[0][j] = 1;
			}
			if (M[1][j - 1] * Ltl * loadedRoll(sequence.charAt(j)) >= M[0][j - 1] * (1-Ltl)
					* loadedRoll(sequence.charAt(j))) {
				M[1][j] = M[1][j - 1] * Ltl * loadedRoll(sequence.charAt(j));
				//Initialized to loaded
				P[1][j] = 1;
			}

			else {
				M[1][j] = M[1][j - 1] * (1-Ftf) * loadedRoll(sequence.charAt(j));
				//initialized to fair
				P[1][j] = 0;
			}
			j++;
		}
		
		//concatenates the output to the output string
		//whichever is the greatest probability
		String output = "";
		FileWriter out = new FileWriter(outputFile);
		
		if (M[0][sequence.length() - 1] >= M[1][sequence.length() - 1]) {
			output = output
					.concat("Probability of this particular sequence: " + M[0][sequence.length() - 1]);
			printPath(P, 0, sequence.length() - 1);
		}

		else {
			output = output
					.concat("Probability of this particular sequence: " + M[1][sequence.length() - 1]);
			printPath(P, 1, sequence.length() - 1);
		}

		output = output.concat("\n");
		
		for (String str : rolls1)
		{
			output=str;
			//writes to the output file	
			out.write(output);			
		}
		
//		output = output.concat("rolls");
		
		out.close();

		return output;
	}

	static String temp = "";

	
	//This prints the path... Algorithm origin from LIMING CAIs lecture notes Fall 2015
	public static void printPath(int[][] path, int i, int j) {
		temp = "";
		if (j >= 0) {
			printPath(path, path[i][j], j - 1);
			if (path[i][j] == 0) {
				rolls1.add("F");
			}

			else {
				rolls1.add("L");
			}
		}
		
	}

	

}